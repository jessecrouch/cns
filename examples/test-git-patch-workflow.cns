Story: Git patch generation workflow simulating SWE-Bench agent pattern

Given:
  initial_branches: String
  code1: Number
  create_status: Number
  add_status: Number
  status_output: String
  status_code: Number
  patch: String
  diff_code: Number
  patch_size: Number
  cached_patch: String
  cached_code: Number
  commit_status: Number
  recent_log: String
  log_code: Number
  cleanup: String
  cleanup_code: Number
  final_status: String
  final_code: Number

Step 1 → Get current branch info
  Because: checking initial git state
  Effect: GIT BRANCH INTO initial_branches WITH EXIT_CODE code1
  Then: PRINT "=== Git Patch Generation Workflow ==="
        PRINT "\n--- Step 1: Initial State ---"
        PRINT "Current branches:"
        PRINT initial_branches

Step 2 → Create feature branch
  Because: creating isolated branch for changes
  Effect: GIT BRANCH CREATE "fix-issue-123" WITH STATUS create_status
  Then: PRINT "\n--- Step 2: Create Feature Branch ---"
        IF create_status = 0 THEN
          PRINT "Created branch: fix-issue-123"
        ELSE
          PRINT "Note: Branch may already exist (status: "
          PRINT create_status
          PRINT ")"
        END

Step 3 → Make test change
  Because: creating a test file to demonstrate workflow
  Effect: WRITE FILE "test-change.txt" CONTENT "This is a test change for issue #123"
  Then: PRINT "\n--- Step 3: Make Test Changes ---"
        PRINT "Created test file: test-change.txt"

Step 4 → Stage the changes
  Because: adding file to git index
  Effect: GIT ADD "test-change.txt" WITH STATUS add_status
  Then: PRINT "\n--- Step 4: Stage Changes ---"
        IF add_status = 0 THEN
          PRINT "Changes staged successfully"
        END

Step 5 → Check status before commit
  Because: verifying changes are staged
  Effect: GIT STATUS INTO status_output WITH EXIT_CODE status_code
  Then: PRINT "\n--- Step 5: Check Status ---"
        PRINT "Git status:"
        PRINT status_output

Step 6 → Generate unified diff patch
  Because: creating patch in unified format for SWE-Bench
  Effect: GIT DIFF "test-change.txt" INTO patch WITH EXIT_CODE diff_code
  Then: PRINT "\n--- Step 6: Generate Unified Diff Patch ---"
        IF diff_code = 0 THEN
          LET patch_size = LENGTH patch
          PRINT "Generated patch ("
          PRINT patch_size
          PRINT " bytes)"
          IF patch_size > 0 THEN
            PRINT "\nPatch contents:"
            PRINT patch
          ELSE
            PRINT "Note: No unstaged changes to generate patch from"
            PRINT "Attempting to get cached diff..."
            SHELL "git diff --cached test-change.txt" INTO cached_patch WITH EXIT_CODE cached_code
            IF cached_code = 0 THEN
              PRINT "Cached diff:"
              PRINT cached_patch
            END
          END
        END

Step 7 → Commit the changes
  Because: committing staged changes
  Effect: GIT COMMIT "Fix issue #123: Add test file" WITH STATUS commit_status
  Then: PRINT "\n--- Step 7: Commit Changes ---"
        IF commit_status = 0 THEN
          PRINT "Changes committed successfully"
        ELSE
          PRINT "Commit status: "
          PRINT commit_status
        END

Step 8 → View commit log
  Because: verifying commit was recorded
  Effect: GIT LOG "--oneline -3" INTO recent_log WITH EXIT_CODE log_code
  Then: PRINT "\n--- Step 8: View Recent Commits ---"
        PRINT "Recent commits:"
        PRINT recent_log

Step 9 → Cleanup test file
  Because: removing test artifacts
  Effect: SHELL "rm -f test-change.txt" INTO cleanup WITH EXIT_CODE cleanup_code
  Then: PRINT "\n--- Step 9: Cleanup ---"
        PRINT "Removed test file"

Step 10 → Show final state
  Because: verifying final git status
  Effect: GIT STATUS INTO final_status WITH EXIT_CODE final_code
  Then: PRINT "\n--- Step 10: Final State ---"
        PRINT "Final git status:"
        PRINT final_status

End: Return "Patch workflow completed"
  Because: demonstrated complete SWE-Bench workflow

