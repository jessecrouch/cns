Story: Run a REAL webserver that responds to HTTP requests

Given:
  port: Integer = 8080 [network port]
  server_socket: Socket [network listener]
  response_body: String = "Hello from CNS!" [response content]
  connection_count: Integer = 0 [track connections]
  max_connections: Integer = 3 [stop after this many]
  
Step 1 → Create server_socket on port
  Effect: Create socket server_socket on 8080
  Because: We need to bind to port 8080 for incoming HTTP requests
  
Step 2 → Accept connection on server_socket
  Effect: Accept connection on server_socket
  Because: Wait for a client to connect
  Then: connection_count becomes connection_count + 1
  Effect: Print "Connection #{connection_count} accepted"
  
Step 3 → Read HTTP request from client
  Effect: Network read
  Because: We need to receive the client's HTTP request
  Effect: Print "Request received"
  
Step 4 → Send HTTP response to client
  Effect: Send "HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 16

{response_body}
" to client
  Because: Respond with HTTP headers and body
  Effect: Print "Response sent"
  
Step 5 → Close client connection
  Effect: Close connection
  Because: Clean up the client connection
  
Step 6 → Check if more connections needed
  Because: We want to handle multiple requests
  If connection_count < max_connections
  Then: repeat from Step 2
  Otherwise: go to End
  
Error:
  Return "Server error"
  Effect: Log "Error in webserver"
  Effect: Close socket server_socket
  Because: Clean up on error
  
End: Return connection_count
  Effect: Print "Server handled {connection_count} connections"
  Effect: Close socket server_socket
  Because: Clean up server resources
