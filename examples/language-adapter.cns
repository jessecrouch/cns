#!/usr/bin/env cns-run

Story: Language Adapter Framework for SWE-bench Multilingual
    Version: 1.8.0-alpha
    Purpose: Dynamically detect language and extract build/test commands
    Target: Enable language-agnostic agent behavior
    
    Strategy:
    1. Check for metadata files (Cargo.toml, go.mod, package.json, pom.xml, etc.)
    2. Extract commands from CI configs (.github/workflows/*.yml, .gitlab-ci.yml)
    3. Introspect toolchain capabilities (cargo --help, go help test)
    4. Store knowledge in Map for reuse across agent runs

Given:
    - Repository path to analyze
    - Access to file system for metadata detection
    - Available toolchains: Rust, Go, Python, Java, Node.js, C/C++

When:

FUNCTION detect_language(repo_path) {
    # Returns: Map with keys {language, build_cmd, test_cmd, format_cmd}
    
    VAR result = MAP()
    SET result["language"] = "unknown"
    SET result["build_cmd"] = ""
    SET result["test_cmd"] = ""
    SET result["format_cmd"] = ""
    
    # Strategy 1: Detect from metadata files
    
    # Rust detection
    VAR cargo_toml = CONCAT(repo_path, "/Cargo.toml")
    IF FILE_EXISTS(cargo_toml) THEN
        SET result["language"] = "rust"
        SET result["build_cmd"] = "cargo build"
        SET result["test_cmd"] = "cargo test"
        SET result["format_cmd"] = "cargo fmt --check"
        RETURN result
    END
    
    # Go detection
    VAR go_mod = CONCAT(repo_path, "/go.mod")
    IF FILE_EXISTS(go_mod) THEN
        SET result["language"] = "go"
        SET result["build_cmd"] = "go build ./..."
        SET result["test_cmd"] = "go test ./..."
        SET result["format_cmd"] = "go fmt ./..."
        RETURN result
    END
    
    # Node.js/TypeScript detection
    VAR package_json = CONCAT(repo_path, "/package.json")
    IF FILE_EXISTS(package_json) THEN
        # Read package.json to determine if TypeScript or JavaScript
        VAR pkg_content = FILE_READ(package_json)
        
        IF STRING_CONTAINS(pkg_content, "typescript") THEN
            SET result["language"] = "typescript"
            SET result["build_cmd"] = "npm run build"
            SET result["test_cmd"] = "npm test"
            SET result["format_cmd"] = "npm run format"
        ELSE
            SET result["language"] = "javascript"
            SET result["build_cmd"] = "npm run build"
            SET result["test_cmd"] = "npm test"
            SET result["format_cmd"] = "npm run format"
        END
        RETURN result
    END
    
    # Java/Maven detection
    VAR pom_xml = CONCAT(repo_path, "/pom.xml")
    IF FILE_EXISTS(pom_xml) THEN
        SET result["language"] = "java"
        SET result["build_cmd"] = "mvn compile"
        SET result["test_cmd"] = "mvn test"
        SET result["format_cmd"] = "mvn spotless:check"
        RETURN result
    END
    
    # Java/Gradle detection
    VAR build_gradle = CONCAT(repo_path, "/build.gradle")
    IF FILE_EXISTS(build_gradle) THEN
        SET result["language"] = "java"
        SET result["build_cmd"] = "./gradlew build"
        SET result["test_cmd"] = "./gradlew test"
        SET result["format_cmd"] = "./gradlew spotlessCheck"
        RETURN result
    END
    
    # C/C++ detection (CMake)
    VAR cmake_lists = CONCAT(repo_path, "/CMakeLists.txt")
    IF FILE_EXISTS(cmake_lists) THEN
        SET result["language"] = "cpp"
        SET result["build_cmd"] = "cmake -B build && cmake --build build"
        SET result["test_cmd"] = "cd build && ctest"
        SET result["format_cmd"] = "clang-format --dry-run src/**/*"
        RETURN result
    END
    
    # C/C++ detection (Makefile)
    VAR makefile = CONCAT(repo_path, "/Makefile")
    IF FILE_EXISTS(makefile) THEN
        SET result["language"] = "c"
        SET result["build_cmd"] = "make"
        SET result["test_cmd"] = "make test"
        SET result["format_cmd"] = ""
        RETURN result
    END
    
    # Python detection (setup.py, pyproject.toml)
    VAR setup_py = CONCAT(repo_path, "/setup.py")
    VAR pyproject_toml = CONCAT(repo_path, "/pyproject.toml")
    IF FILE_EXISTS(setup_py) OR FILE_EXISTS(pyproject_toml) THEN
        SET result["language"] = "python"
        SET result["build_cmd"] = "pip install -e ."
        SET result["test_cmd"] = "pytest"
        SET result["format_cmd"] = "black --check ."
        RETURN result
    END
    
    RETURN result
END

FUNCTION extract_ci_commands(repo_path) {
    # Strategy 2: Learn from CI configs
    # Returns: Map with keys {build_cmd, test_cmd}
    
    VAR result = MAP()
    SET result["build_cmd"] = ""
    SET result["test_cmd"] = ""
    
    # GitHub Actions workflow detection
    VAR workflow_pattern = CONCAT(repo_path, "/.github/workflows/*.yml")
    VAR workflows = SHELL("find " + repo_path + "/.github/workflows -name '*.yml' 2>/dev/null || true")
    
    IF NOT STRING_EQUALS(workflows, "") THEN
        # Read first workflow file
        VAR lines = STRING_SPLIT(workflows, "\n")
        IF LENGTH(lines) > 0 THEN
            VAR first_workflow = INDEX(lines, 0)
            IF FILE_EXISTS(first_workflow) THEN
                VAR content = FILE_READ(first_workflow)
                
                # Extract build/test commands using regex patterns
                # Pattern 1: "run: cargo test" -> extract "cargo test"
                # Pattern 2: "- cargo build" -> extract "cargo build"
                
                # Split by lines and look for common patterns
                VAR ci_lines = STRING_SPLIT(content, "\n")
                FOREACH line IN ci_lines DO
                    # Look for test commands
                    IF STRING_CONTAINS(line, "run:") AND 
                       (STRING_CONTAINS(line, "test") OR STRING_CONTAINS(line, "pytest")) THEN
                        # Extract command after "run:"
                        VAR parts = STRING_SPLIT(line, "run:")
                        IF LENGTH(parts) > 1 THEN
                            VAR cmd = TRIM(INDEX(parts, 1))
                            SET result["test_cmd"] = cmd
                        END
                    END
                    
                    # Look for build commands
                    IF STRING_CONTAINS(line, "run:") AND 
                       (STRING_CONTAINS(line, "build") OR STRING_CONTAINS(line, "compile")) THEN
                        VAR parts = STRING_SPLIT(line, "run:")
                        IF LENGTH(parts) > 1 THEN
                            VAR cmd = TRIM(INDEX(parts, 1))
                            SET result["build_cmd"] = cmd
                        END
                    END
                END
            END
        END
    END
    
    RETURN result
END

FUNCTION introspect_toolchain(language) {
    # Strategy 3: Query toolchain for available commands
    # Returns: Map with available commands and options
    
    VAR result = MAP()
    SET result["available"] = FALSE
    SET result["version"] = ""
    SET result["test_options"] = ""
    
    IF STRING_EQUALS(language, "rust") THEN
        VAR version = SHELL("cargo --version 2>&1 || echo 'not found'")
        IF NOT STRING_CONTAINS(version, "not found") THEN
            SET result["available"] = TRUE
            SET result["version"] = version
            # Extract test options from cargo help
            VAR help_output = SHELL("cargo test --help 2>&1 | grep -E '^\s+--' | head -5 || true")
            SET result["test_options"] = help_output
        END
    END
    
    IF STRING_EQUALS(language, "go") THEN
        VAR version = SHELL("go version 2>&1 || echo 'not found'")
        IF NOT STRING_CONTAINS(version, "not found") THEN
            SET result["available"] = TRUE
            SET result["version"] = version
            VAR help_output = SHELL("go help test 2>&1 | head -10 || true")
            SET result["test_options"] = help_output
        END
    END
    
    IF STRING_EQUALS(language, "python") THEN
        VAR version = SHELL("python3 --version 2>&1 || echo 'not found'")
        IF NOT STRING_CONTAINS(version, "not found") THEN
            SET result["available"] = TRUE
            SET result["version"] = version
            VAR pytest_check = SHELL("pytest --version 2>&1 || echo 'not installed'")
            SET result["test_options"] = pytest_check
        END
    END
    
    IF STRING_EQUALS(language, "java") THEN
        VAR version = SHELL("mvn --version 2>&1 || echo 'not found'")
        IF NOT STRING_CONTAINS(version, "not found") THEN
            SET result["available"] = TRUE
            SET result["version"] = version
        END
    END
    
    IF STRING_EQUALS(language, "javascript") OR STRING_EQUALS(language, "typescript") THEN
        VAR version = SHELL("npm --version 2>&1 || echo 'not found'")
        IF NOT STRING_CONTAINS(version, "not found") THEN
            SET result["available"] = TRUE
            SET result["version"] = version
        END
    END
    
    IF STRING_EQUALS(language, "c") OR STRING_EQUALS(language, "cpp") THEN
        VAR version = SHELL("gcc --version 2>&1 | head -1 || echo 'not found'")
        IF NOT STRING_CONTAINS(version, "not found") THEN
            SET result["available"] = TRUE
            SET result["version"] = version
        END
    END
    
    RETURN result
END

FUNCTION adapt_repo(repo_path) {
    # Main function: Complete language adaptation pipeline
    # Returns: Comprehensive Map with all language metadata
    
    PRINT("=== Language Adapter Framework v1.8.0 ===")
    PRINT("Analyzing repository: " + repo_path)
    
    # Step 1: Detect language from metadata
    VAR lang_info = detect_language(repo_path)
    PRINT("Detected language: " + lang_info["language"])
    
    IF STRING_EQUALS(lang_info["language"], "unknown") THEN
        PRINT("WARNING: Could not detect language from metadata files")
        RETURN lang_info
    END
    
    # Step 2: Extract commands from CI configs
    VAR ci_commands = extract_ci_commands(repo_path)
    
    # Override defaults with CI-learned commands if available
    IF NOT STRING_EQUALS(ci_commands["build_cmd"], "") THEN
        PRINT("Found build command in CI: " + ci_commands["build_cmd"])
        SET lang_info["build_cmd"] = ci_commands["build_cmd"]
    END
    
    IF NOT STRING_EQUALS(ci_commands["test_cmd"], "") THEN
        PRINT("Found test command in CI: " + ci_commands["test_cmd"])
        SET lang_info["test_cmd"] = ci_commands["test_cmd"]
    END
    
    # Step 3: Verify toolchain availability
    VAR toolchain = introspect_toolchain(lang_info["language"])
    SET lang_info["toolchain_available"] = toolchain["available"]
    SET lang_info["toolchain_version"] = toolchain["version"]
    
    IF toolchain["available"] THEN
        PRINT("Toolchain available: " + toolchain["version"])
    ELSE
        PRINT("WARNING: Toolchain not available for " + lang_info["language"])
    END
    
    # Step 4: Store metadata for reuse
    SET lang_info["repo_path"] = repo_path
    SET lang_info["timestamp"] = NOW()
    
    PRINT("=== Adaptation Complete ===")
    PRINT("Build: " + lang_info["build_cmd"])
    PRINT("Test: " + lang_info["test_cmd"])
    
    RETURN lang_info
END

Then:
  # Demo: Adapt current repository
  VAR current_repo = SHELL("pwd")
  VAR adapter_result = adapt_repo(current_repo)
  
  # Print full results
  PRINT("\n=== Full Adapter Metadata ===")
  FOREACH key IN KEYS(adapter_result) DO
    VAR value = GET(adapter_result, key)
    PRINT(key + ": " + value)
  END

End: adapter_result
