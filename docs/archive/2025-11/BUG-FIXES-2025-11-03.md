# Critical Bug Fixes - November 3, 2025

## Summary

During Grok LLM testing preparation, two critical bugs were discovered and fixed in the CNS validator and interpreter. Both bugs affected core language functionality and would have caused widespread issues with LLM-generated code.

---

## Bug #1: Validator Doesn't Recognize TRUE/FALSE as Literals

### Severity
**CRITICAL** - Blocked all boolean logic in CNS programs

### Description
The validator treated `TRUE` and `FALSE` as undeclared variables instead of boolean literals, causing validation errors on any code using boolean values.

### Root Cause
**File**: `src/cns-validator.lisp`  
**Line**: 204  
**Issue**: The `member` function was called without `:test #'string-equal` parameter

```lisp
;; BROKEN CODE:
(not (member (string-upcase tok) '("BECOMES" "TO" ... "TRUE" "FALSE" ...)))
```

The `member` function defaults to using `eql` for comparison, which always returns `NIL` when comparing strings (since `eql` tests object identity, not string content). This caused TRUE/FALSE to never be found in the keyword list.

### Example Failure

```cns
Story: Test boolean

Given:
  flag: Boolean = TRUE

Step 1 → Set to false
  Because: Test FALSE literal
  Then: flag becomes FALSE

End: Return flag
```

**Error Output:**
```
ERROR: Variable 'FALSE' used before declaration in Step 1
  Context: flag becomes FALSE
```

### Fix Applied

**File**: `src/cns-validator.lisp`  
**Line**: 204  
**Change**: Added `:test #'string-equal` to member check

```lisp
;; FIXED CODE:
(not (member (string-upcase tok) '("BECOMES" "TO" ... "TRUE" "FALSE" ...)
             :test #'string-equal))
```

### Verification

```bash
$ ./cns-validate test-boolean.cns
✓ No errors found
✓ No warnings
Overall: VALID (ready for execution)

$ ./cns-run test-boolean.cns
Return: NIL  # Correct: FALSE converts to NIL in Lisp
```

### Impact
- **Before Fix**: 100% of programs using TRUE/FALSE failed validation
- **After Fix**: All boolean literals work correctly
- **LLM Impact**: Grok and other LLMs frequently use TRUE/FALSE in generated code

---

## Bug #2: Incorrect Operator Precedence with AND/OR

### Severity
**CRITICAL** - Caused silent logic errors in complex conditions

### Description
Boolean operators (AND/OR) had incorrect precedence relative to comparison operators, causing expressions to be parsed in the wrong order. This led to subtle but critical logic errors.

### Root Cause
**File**: `src/cns.lisp`  
**Function**: `eval-expr`  
**Lines**: 1666-1780 (original)  
**Issue**: Comparison operators were checked BEFORE AND/OR in the `cond` statement

In expression evaluation, operators should be checked in **reverse precedence order** (lowest precedence first):
1. OR (lowest)
2. AND
3. NOT
4. Comparisons (=, !=, <, >, <=, >=)
5. Arithmetic (+, -, *, /, %) (highest)

The code had comparisons checked BEFORE AND/OR, causing expressions to split incorrectly.

### Example Failure

**Expression**: `n % i = 0 AND n != i`  
**Expected Parse**: `(n % i = 0) AND (n != i)`  
**Actual Parse**: `(n % i = 0 AND n) != i`

**Why This Happened**:
1. Code checks for `!=` first (line 1720)
2. Finds `!=` in the expression
3. Splits on the FIRST `!=`: left=`n % i = 0 AND n`, right=`i`
4. Evaluates `n % i = 0 AND n` → `(1 = 0) AND 17` → `FALSE AND 17` → NIL
5. Evaluates `NIL != 2` → TRUE (wrong!)

**Test Case**:
```cns
Story: Test prime checking

Given:
  n: Integer = 17  # prime number
  i: Integer = 2
  result: Integer = 0

Step 1 → Check if divisible
  Because: Should be FALSE (17 % 2 = 1, not 0)
  If: n % i = 0 AND n != i
    Then: result becomes 1  # Wrong branch taken!
  Otherwise:
    Then: result becomes 2

End: Return result
```

**Before Fix**: Returns 1 (WRONG - condition should be FALSE)  
**After Fix**: Returns 2 (CORRECT - goes to Otherwise)

### Fix Applied

**File**: `src/cns.lisp`  
**Lines**: Added lines ~1665-1684, removed lines ~1782-1800  
**Change**: Moved AND/OR/NOT checks to execute BEFORE comparison operators

```lisp
;; FIXED CODE ORDER:
(cond
  ;; ... literals, variables, numbers ...
  
  ;; Boolean: OR (LOWEST PRECEDENCE - check first)
  ((search " OR " (string-upcase trimmed))
   ...)
  
  ;; Boolean: AND (check before comparisons)
  ((search " AND " (string-upcase trimmed))
   ...)
  
  ;; Boolean: NOT (unary prefix)
  ((starts-with (string-upcase trimmed) "NOT ")
   ...)
  
  ;; Comparison: <=, >=, <, >, ==, !=, =
  ;; (checked AFTER boolean operators)
  ...
)
```

### Verification

#### Test 1: AND with Comparisons
```cns
If: n % i = 0 AND n != i  # n=17, i=2
  # Expected: (17 % 2 = 0) AND (17 != 2) = FALSE AND TRUE = FALSE
  # Goes to Otherwise ✓
```

#### Test 2: OR with Comparisons
```cns
If: a > 10 OR b < 10  # a=5, b=3
  # Expected: (5 > 10) OR (3 < 10) = FALSE OR TRUE = TRUE
  # Executes Then ✓
```

#### Test 3: Complex Nested Expression
```cns
If: a > b OR b > c AND c < 10  # a=5, b=10, c=3
  # Expected: (5 > 10) OR ((10 > 3) AND (3 < 10))
  #         = FALSE OR (TRUE AND TRUE)
  #         = FALSE OR TRUE
  #         = TRUE
  # Executes Then ✓
```

#### Test 4: NOT with Comparisons
```cns
If: NOT a > b  # a=5, b=10
  # Expected: NOT (5 > 10) = NOT FALSE = TRUE
  # Executes Then ✓
```

### Impact
- **Before Fix**: Complex boolean expressions evaluated incorrectly
- **After Fix**: All operator precedence matches standard programming conventions
- **LLM Impact**: Critical for LLM-generated code which often uses complex conditions
- **Silent Errors**: This bug caused logic errors that passed validation but computed wrong results

---

## Testing Results

### Comprehensive Test Suite

Created `test-bug-fixes.cns` to verify both fixes:

```cns
Story: Comprehensive test of Bug #1 and Bug #2 fixes

Given:
  n: Integer = 17
  i: Integer = 2
  is_prime: Boolean = TRUE
  test_and: Integer = 0
  test_or: Integer = 0
  test_not: Integer = 0

Step 1 → Test Bug #1: TRUE/FALSE as literals
  Because: Validator should recognize TRUE and FALSE
  Then: is_prime becomes TRUE
  Then: is_prime becomes FALSE
  Then: is_prime becomes TRUE

Step 2 → Test Bug #2: AND with comparisons
  Because: Should parse as (n % i = 0) AND (n != i)
  If: n % i = 0 AND n != i
    Then: test_and becomes 999
  Otherwise:
    Then: test_and becomes 1

Step 3 → Test OR with comparisons
  Because: Should parse as (n > 20) OR (i < 5)
  If: n > 20 OR i < 5
    Then: test_or becomes 1
  Otherwise:
    Then: test_or becomes 999

Step 4 → Test NOT with comparisons
  Because: Should parse as NOT (n < 10)
  If: NOT n < 10
    Then: test_not becomes 1
  Otherwise:
    Then: test_not becomes 999

Step 5 → Verify all passed
  Because: All tests should equal 1
  If: test_and = 1 AND test_or = 1 AND test_not = 1
    Then: is_prime becomes TRUE
  Otherwise:
    Then: is_prime becomes FALSE

End: Return is_prime
```

**Result**: ✅ Returns TRUE (all tests pass)

### Regression Testing

Verified all core examples still work:
- ✅ `examples/core/factorial.cns` → Returns 120
- ✅ `examples/core/sum-range.cns` → Returns 4950
- ✅ `examples/core/is-prime.cns` → Returns 1 (17 is prime)
- ✅ `examples/core/hello.cns` → Returns 3
- ✅ All validation passes with no errors

---

## Files Modified

### 1. src/cns-validator.lisp
**Lines Changed**: 204-207  
**Change Type**: Bug fix (added `:test #'string-equal`)  
**Lines of Code**: 1 parameter added

### 2. src/cns.lisp
**Lines Changed**: ~1665-1684 (added), ~1782-1800 (removed)  
**Change Type**: Major refactoring (moved operator precedence)  
**Lines of Code**: ~20 lines moved, no net change

---

## Lessons Learned

### 1. String Comparison in Lisp
Always use `:test #'equal` or `:test #'string-equal` when using `member` with string lists. The default `eql` test only works for symbols and numbers.

### 2. Operator Precedence in Parsers
When implementing expression evaluation with `cond`:
- Check operators in **reverse precedence order** (lowest precedence first)
- This ensures correct parsing of complex expressions
- Boolean operators (AND/OR) must be checked before arithmetic/comparison operators

### 3. Testing Complex Conditions
- Simple tests may pass even with precedence bugs
- Need tests that combine multiple operator types
- Both validation AND execution testing are critical

### 4. LLM Code Generation
These bugs would have severely impacted LLM-generated code:
- LLMs naturally use TRUE/FALSE literals
- LLMs generate complex boolean conditions
- Silent logic errors are harder to detect than validation errors

---

## Operator Precedence Reference

### Correct Order (Low to High)
1. **OR** - Binary, lowest precedence
2. **AND** - Binary
3. **NOT** - Unary prefix
4. **Comparisons** - `=`, `!=`, `<`, `>`, `<=`, `>=`, `≠`, `≤`, `≥`
5. **Addition/Subtraction** - `+`, `-`
6. **Multiplication/Division/Modulo** - `*`, `/`, `%` (highest precedence)

### Implementation in eval-expr
Check operators in **reverse order** in the `cond` statement:
```lisp
(cond
  ;; Lowest precedence checked FIRST
  ((search " OR " ...) ...)
  ((search " AND " ...) ...)
  ((starts-with "NOT " ...) ...)
  
  ;; Comparisons
  ((search "<=" ...) ...)
  ((search ">=" ...) ...)
  ((search "!=" ...) ...)
  ((search "=" ...) ...)
  
  ;; Arithmetic (would go here if not already elsewhere)
  ((position #\+ ...) ...)
  ((position #\* ...) ...)
  
  ;; Highest precedence checked LAST
)
```

---

## Status

✅ **Both bugs fixed and verified**  
✅ **All regression tests pass**  
✅ **Ready for LLM testing**  
✅ **Documentation complete**

**Date Fixed**: November 3, 2025  
**Fixed By**: Claude (OpenCode) during Grok testing preparation  
**Commits**: Validator fix + Operator precedence refactoring
