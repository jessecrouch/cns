# UPDATES.md: CNS Webserver Milestone & Project Management

This document provides the strategic roadmap for evolving **Causal Narrative Script (CNS)** to handle complex tasks like webserver generation. Focus: **Common Lisp implementation**.

## Commander's Intent

**Objective**: Develop CNS into a robust, LLM-friendly language that enables reliable, unsupervised code generation for complex tasks like a webserver. Create a system where LLMs produce clear, executable CNS code with explicit causality, minimizing errors like hallucinations or implicit logic.

**Success Criteria**: CNS webserver that runs correctly (responds to `curl http://localhost:8080/`), generated by an LLM in ≤3 iterations, with traceable narrative steps.

**Flexibility**: You have full authority to prioritize, modify, or deviate from suggestions. This guide is a flexible framework aligned with making CNS a practical tool for LLMs.

---

## Current State

Minimal CNS interpreter in Common Lisp with:
- **Syntax**: `Story:`, `Given:`, `Step →`, `Because:`, `Effect:`, `If/Then/Otherwise`, `End:`
- **Features**: Basic expressions, lists, I/O (file/console), network effects (sockets), loops via `repeat from Step`
- **Execution**: Parses CNS to S-expressions, interprets with hash-table environment, traces steps
- **Real Socket Support**: Uses `usocket` for actual network I/O
- **Examples**: factorial, fibonacci, webserver (see `examples/demo-webserver.cns`)

---

## Goal: LLM-Generated Webserver

Enable LLMs to generate working webservers from prompts like "write a webserver". Example CNS output:

```
Story: Run a simple webserver
Given:
  port: Integer = 8080 [network port]
  routes: List = [("GET /", "Hello, World!")]
  server_socket: Socket
Step 1 → Create server_socket on port
  Effect: bind socket
  Because: Listen for incoming connections
Step 2 → Accept connection on server_socket
  Effect: network read
  Because: Receive client request
  Then: request = parse HTTP request
Step 3 → Find route matching request
  Because: Determine response based on URL
Step 4 → Send response to client
  Effect: network write
  Because: Return requested content
  Then: go to Step 2
End: Close server_socket
  Because: Clean up resources
```

**Why This Matters**: Proves CNS handles real-world complexity with explicit causality, enabling LLMs to tackle APIs, databases, games, etc.

---

## Project Management: Context Control

### Principles
- **Modular Tasks**: Small, focused units (one commit or session)
- **Narrative Documentation**: CNS-like commit messages ("Add HTTP parsing to enable routing")
- **Prioritization**: One phase at a time, defer non-critical tasks
- **Traceability**: Log progress clearly
- **Flexibility**: Adapt to feedback per Commander's Intent

### Task Structure
- **What**: Specific goal
- **Why**: Reason tied to project goals
- **How**: Brief approach (details in code/examples)
- **Test**: Verification step

---

## Development Roadmap

### Phase 1: Language Features Enhancement (1-2 weeks)

**Tasks**:
1. **Socket Support** ✓ (DONE - using `usocket`)
   - Support `Socket` type and effects (bind, accept, send, close)
   - See `src/cns.lisp` implementation

2. **HTTP Parsing**
   - Parse HTTP requests (method, URL, query params)
   - Use `cl-ppcre` for pattern matching
   - Test: Parse "GET / HTTP/1.1" → extract method and URL

3. **Advanced Control Flow**
   - Enhance `For each` for lists and `Match` for routing
   - Enable dynamic route matching
   - Test: Match routes from list against request

4. **Error Handling**
   - Formalize `Error:` blocks for socket failures, invalid requests
   - Use `handler-case` in interpreter
   - Test: Simulate failure, verify error block execution

### Phase 2: LLM Integration (2-3 weeks)

**Tasks**:
5. **Prompt Templates**
   - Design prompts for consistent CNS generation
   - Store in `prompts/` directory
   - Test: Generate webserver, verify structure

6. **Dataset Creation**
   - Create 50-100 CNS webserver examples (single-route, multi-route, query params, errors)
   - Save to `dataset/` as JSON/CSV
   - Train LLMs to map tasks to CNS patterns
   - Test: Verify examples parse and execute

7. **Validation System**
   - Check CNS for completeness (required vars, `Because:` clauses, effects)
   - Catch errors before execution
   - Critical for unsupervised coding
   - Test: Validate example, catch missing declarations

8. **Feedback Loop**
   - Re-prompt on errors with specific fixes
   - Enable unsupervised refinement
   - Limit to 3 retries
   - Test: Simulate error, verify correction

### Phase 3: Testing & Validation (2 weeks)

**Tasks**:
9. **Test Suite**
   - Test single route, multi-route, query params, 404, socket errors
   - Use `curl` for integration tests
   - Maintain in `tests/llm-tests/`

10. **Benchmarks**
    - Compare CNS vs. Python/Flask for error rate, iterations
    - Prove CNS advantage in reducing LLM errors
    - Document results

### Phase 4: Unsupervised Robustness (1-2 weeks)

**Tasks**:
11. **Sandbox Execution**
    - Run CNS in isolated environment (Docker)
    - Add timeout handling for safety
    - Catch crashes gracefully

12. **Self-Correction**
    - Auto-retry on errors with refined prompts
    - Enable autonomous debugging
    - Cap at 3 retries

---

## Timeline

- **Phase 1**: 1-2 weeks (language features) - Resources: `usocket`, `cl-ppcre`
- **Phase 2**: 2-3 weeks (LLM integration) - Resources: LLM APIs, JSON
- **Phase 3**: 2 weeks (testing/benchmarks) - Resources: Test frameworks
- **Phase 4**: 1-2 weeks (robustness) - Resources: Docker

**Total**: 6-9 weeks part-time

---

## Implementation Notes

### Resources
- **Socket I/O**: `usocket` library (already integrated)
- **HTTP Parsing**: `cl-ppcre` for regex
- **Testing**: FiveAM or similar
- **Execution**: SBCL (Steel Bank Common Lisp)

### Code Organization
- **Interpreter**: `src/cns.lisp`
- **Examples**: `examples/` (especially `demo-webserver.cns`)
- **Tests**: `tests/llm-tests/`
- **Prompts**: `prompts/`
- **Dataset**: `dataset/`

### Commit Style
Use CNS-style narrative commits:
- "Add HTTP parsing to enable webserver routing"
- "Implement error blocks for robust failure handling"

---

## Next Immediate Steps

1. **HTTP Parsing**: Add `parse-http` function using `cl-ppcre`
2. **Route Matching**: Implement dynamic route lookup in interpreter
3. **Prompt Template**: Create webserver generation prompt
4. **Test & Iterate**: Generate webserver with LLM, refine based on errors

---

## Why This Approach

- **Webserver Test**: Validates CNS on complex, real-world task
- **Lisp Implementation**: Homoiconicity enables rapid iteration
- **LLM Integration**: Prompts + validation enable unsupervised coding
- **Modular Tasks**: Keeps context manageable
- **Flexibility**: Empowers adaptation to new insights

Let's make CNS the go-to language for LLM coding!
