[
  {
    "id": 1,
    "task": "Create a webserver on port 8080 that responds with 'Hello, World!'",
    "category": "basic",
    "cns_code": "Story: Run a simple webserver on port 8080\n\nGiven:\n  port: Integer [network port] = 8080\n  server_socket: Socket [network listener]\n  response: String = \"Hello, World!\" [default response]\n  connection_count: Integer = 0 [track connections]\n  \nStep 1 → Create server_socket on port\n  Effect: Create socket server_socket on 8080\n  Because: We need to listen for incoming HTTP connections\n  \nStep 2 → Accept connection on server_socket\n  Effect: Accept connection\n  Because: Wait for client request\n  Then: connection_count becomes connection_count + 1\n  \nStep 3 → Parse HTTP request\n  Effect: Network read\n  Because: Receive and understand client's HTTP request\n  \nStep 4 → Send response to client\n  Effect: Send \"HTTP/1.1 200 OK\\nContent-Type: text/plain\\n\\n{response}\" to client\n  Because: Return the greeting to the client\n  \nStep 5 → If connection_count < 3\n  Then: repeat from Step 2\n  Otherwise: go to End\n  Because: Handle up to 3 connections for this demo\n  \nError:\n  Return \"Server error\"\n  Effect: Log \"Error in webserver\"\n  Because: Handle unexpected failures gracefully\n  \nEnd: Close server_socket\n  Effect: Close socket server_socket\n  Because: Clean up network resources properly\n"
  },
  {
    "id": 2,
    "task": "Create a webserver on port 3000 that handles 10 connections",
    "category": "basic",
    "cns_code": "Story: Run webserver on port 3000 with extended connection handling\n\nGiven:\n  port: Integer = 3000 [network port]\n  server_socket: Socket [network listener]\n  response: String = \"Server is running\" [status message]\n  connection_count: Integer = 0 [track connections]\n  max_connections: Integer = 10 [connection limit]\n  \nStep 1 → Create server_socket on port\n  Effect: Create socket server_socket on 3000\n  Because: We need to bind to port 3000 for incoming requests\n  \nStep 2 → Accept connection on server_socket\n  Effect: Accept connection\n  Because: Wait for next client request\n  Then: connection_count becomes connection_count + 1\n  \nStep 3 → Parse HTTP request\n  Effect: Network read\n  Because: Read and parse client HTTP request\n  \nStep 4 → Send response to client\n  Effect: Send \"HTTP/1.1 200 OK\\n\\n{response}\" to client\n  Because: Respond to client with status message\n  \nStep 5 → If connection_count < max_connections\n  Then: repeat from Step 2\n  Otherwise: go to End\n  Because: Continue serving until connection limit reached\n  \nError:\n  Return \"Connection error\"\n  Effect: Log \"Failed to handle connection\"\n  Because: Log errors for debugging\n  \nEnd: Close server_socket\n  Effect: Close socket server_socket\n  Effect: Print \"Served {connection_count} connections\"\n  Because: Clean up and report final statistics\n"
  },
  {
    "id": 3,
    "task": "Create a webserver with a health check endpoint",
    "category": "routing",
    "cns_code": "Story: Run webserver with health check endpoint\n\nGiven:\n  port: Integer = 8080 [network port]\n  server_socket: Socket [network listener]\n  request_url: String [requested path]\n  response: String [response to send]\n  connection_count: Integer = 0\n  uptime: Integer = 0 [seconds running]\n  \nStep 1 → Create server_socket on port\n  Effect: Create socket server_socket on 8080\n  Because: Bind to port for HTTP connections\n  \nStep 2 → Accept connection on server_socket\n  Effect: Accept connection\n  Because: Wait for client request\n  Then: connection_count becomes connection_count + 1\n  Then: uptime becomes uptime + 1\n  \nStep 3 → Parse HTTP request\n  Effect: Network read\n  Because: Read request to determine endpoint\n  Then: request_url becomes \"/health\"\n  \nStep 4 → If request_url = \"/health\"\n  Then: response becomes \"OK - Uptime: {uptime}s, Connections: {connection_count}\"\n  Otherwise: go to Step 5\n  Because: Handle health check endpoint\n  \nStep 5 → response becomes \"404 Not Found\"\n  Because: No matching route found\n  \nStep 6 → Send response to client\n  Effect: Send \"HTTP/1.1 200 OK\\n\\n{response}\" to client\n  Because: Return response to client\n  \nStep 7 → If connection_count < 5\n  Then: repeat from Step 2\n  Otherwise: go to End\n  Because: Handle multiple connections\n  \nError:\n  Return \"Health check failed\"\n  Effect: Log \"Error in health endpoint\"\n  Because: Handle unexpected errors\n  \nEnd: Close server_socket\n  Effect: Close socket server_socket\n  Because: Release network resources\n"
  },
  {
    "id": 4,
    "task": "Create a webserver that counts visitors and displays the count",
    "category": "stateful",
    "cns_code": "Story: Run visitor counter webserver\n\nGiven:\n  port: Integer = 8080\n  server_socket: Socket [network listener]\n  visitor_count: Integer = 0 [total visitors]\n  response: String [response message]\n  max_visits: Integer = 20 [stop after this many]\n  \nStep 1 → Create server_socket on port\n  Effect: Create socket server_socket on 8080\n  Because: Listen for HTTP connections\n  \nStep 2 → Accept connection on server_socket\n  Effect: Accept connection\n  Because: Accept next visitor\n  Then: visitor_count becomes visitor_count + 1\n  \nStep 3 → Parse HTTP request\n  Effect: Network read\n  Because: Read visitor request\n  \nStep 4 → response becomes \"Welcome! You are visitor #{visitor_count}\"\n  Because: Create personalized greeting with count\n  \nStep 5 → Send response to client\n  Effect: Send \"HTTP/1.1 200 OK\\n\\n{response}\" to client\n  Because: Send visitor count to client\n  \nStep 6 → If visitor_count < max_visits\n  Then: repeat from Step 2\n  Otherwise: go to End\n  Because: Continue until reaching visitor limit\n  \nError:\n  Return \"Counter error\"\n  Effect: Log \"Visitor counting failed\"\n  Because: Handle counting errors gracefully\n  \nEnd: Close server_socket\n  Effect: Print \"Total visitors: {visitor_count}\"\n  Effect: Close socket server_socket\n  Because: Report final count and cleanup\n"
  },
  {
    "id": 5,
    "task": "Create a webserver on port 9000 with different responses for GET and POST",
    "category": "methods",
    "cns_code": "Story: Run webserver with GET and POST handling\n\nGiven:\n  port: Integer = 9000\n  server_socket: Socket [network listener]\n  request_method: String [HTTP method]\n  response: String [response message]\n  connection_count: Integer = 0\n  get_count: Integer = 0 [GET requests]\n  post_count: Integer = 0 [POST requests]\n  \nStep 1 → Create server_socket on port\n  Effect: Create socket server_socket on 9000\n  Because: Bind to port 9000 for connections\n  \nStep 2 → Accept connection on server_socket\n  Effect: Accept connection\n  Because: Wait for client\n  Then: connection_count becomes connection_count + 1\n  \nStep 3 → Parse HTTP request\n  Effect: Network read\n  Because: Read and parse HTTP method\n  Then: request_method becomes \"GET\"\n  \nStep 4 → If request_method = \"GET\"\n  Then: response becomes \"GET request received\"\n  Then: get_count becomes get_count + 1\n  Otherwise: go to Step 5\n  Because: Handle GET requests\n  \nStep 5 → If request_method = \"POST\"\n  Then: response becomes \"POST request received\"\n  Then: post_count becomes post_count + 1\n  Otherwise: go to Step 6\n  Because: Handle POST requests\n  \nStep 6 → response becomes \"Method not supported\"\n  Because: Handle unsupported methods\n  \nStep 7 → Send response to client\n  Effect: Send \"HTTP/1.1 200 OK\\n\\n{response}\" to client\n  Because: Send method-specific response\n  \nStep 8 → If connection_count < 6\n  Then: repeat from Step 2\n  Otherwise: go to End\n  Because: Handle multiple requests\n  \nError:\n  Return \"Method handling error\"\n  Effect: Log \"Failed to process HTTP method\"\n  Because: Log method processing errors\n  \nEnd: Close server_socket\n  Effect: Print \"GET: {get_count}, POST: {post_count}\"\n  Effect: Close socket server_socket\n  Because: Report statistics and cleanup\n"
  }
]
